// 1.4. Реликтовая роща (6)
// В заповеднике растет роща реликтовых деревьев. Для их защиты требуется обнести рощу
// забором. Но для обеспечения доступа к остальной территории заповедника площадь участка,
// окруженного забором, должна быть минимальной. Деревья растут точно в узлах координатной
// сетки на расстоянии одного метра друг от друга. Любое из деревьев имеет хотя бы одного соседа
// (с юга, севера, востока или запада). Забор состоит из блоков длиной в один метр. Чтобы огородить
// одно дерево необходимо 4 блока забора:
// А чтобы огородить такую группу из 9 деревьев нужно 20 блоков:
// По заданной конфигурации рощи найти минимально необходимое число блоков для забора.
// Ввод. В первой строке записаны через пробел два числа N и K (1  N, K  300)– количество
// строк и столбцов данных. В следующих N строках содержатся последовательности из K символов
// (единиц или нулей). Единицей обозначается расположение реликтового дерева, а нулем – его
// отсутствие в узле координатной сетки.
// Вывод. В единственной строке выводится число блоков забора, необходимое для
// огораживания.
// Примеры
// Ввод 1 Ввод 2
// 3 6     5 7
// 001110  0101010
// 011011  1111111
// 011110  0101010
//         1100011
//         0111110
// Вывод 1 Вывод 2
// 16      32

// Канюшкова Мария ПС-21
// Visual Studio 2019

#include <fstream>
#include <vector>
#include <queue>
#include <string>

using namespace std;

struct Position {
    int i, j;
};

const int di[] = {-1, 0, 1, 0};
const int dj[] = {0, 1, 0, -1};

int main() {
    ifstream fin("input.txt");
    ofstream fout("output.txt");

    int n, k;
    fin >> n >> k;

    vector <vector<char>> a(n + 2, vector<char>(k + 2, 0));
    for (int i = 0; i < n; i++) {
        string s;
        fin >> s;
        for (int j = 0; j < k; j++) {
            a[i + 1][j + 1] = s[j] - '0';
        }
    }

    queue <Position> q;
    q.push({0, 0});
    a[0][0] = 2;

    while (!q.empty()) {
        auto pos = q.front();
        q.pop();

        for (int d = 0; d < 4; d++) {
            Position pos2 = pos;
            pos2.i += di[d];
            pos2.j += dj[d];

            if (pos2.i < 0 || pos2.j < 0 || pos2.i >= n + 2 || pos2.j >= k + 2) {
                continue;
            }
            if (a[pos2.i][pos2.j] != 0) {
                continue;
            }

            a[pos2.i][pos2.j] = 2;
            q.push(pos2);
        }
    }

    int ans = 0;
    for (int i = 1; i < n + 1; i++) {
        for (int j = 1; j < k + 1; j++) {
            for (int d = 0; d < 4; d++) {
                if (a[i][j] == 1 && a[i + di[d]][j + dj[d]] == 2) {
                    ans++;
                }
            }
        }
    }

    fout << ans << endl;
}

